# 자료형

## 수자료형

### 실수형

```python
a = 0.3 + 0.6
print(a)

if a == 0.9:
    print(True)
else:
    print(False)
```

소수점값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못해서 원하는 결과를 얻지 못할 수 있다. 이럴 때는 round()함수를 이용한다.

round() 함수를 호출할 때는 인자를 넣는데 첫 번째 인자는 실수형 데이터이고, 두 번째 인자는(반올림하고자하는 위치 -1) 이다.

예를 들어 123.456 을 소수점 셋째 자리에서 반올림하려면 round(123.456, 2)라고 작성하며 결과는 123.46이다.

두번째 인자 없이 인자를 하나만 넣을 때는 소수점 첫째 자리에서 반올림한다.

round() 함수를 이용해서 소수점 특정 자리수에서 반올림하는 예시이다.

흔히 코딩테스트 문제에서는 실수형 데이터를 비교할 때 소수점 다섯 번째 자리에서 반올림한 결과가 같으면 정답으로 인정하는 식으로 처리한다.

```python
print(round(a, 4))

if round(a, 4) == 0.9:
    print(True)
else: 
    print(False)
```


### 수 자료형의 연산

```python
a = 7
b = 3

print(a/b) # 나누기
print(a%b) # 나머지
print(a//b) # 몫

print(a**b) # 거듭제곱  

"""
2.3333333333333335
1
2
343
"""
```

## 리스트 자료형

### 리스트 만들기

```python
#빈 리스트 선언 방법1
a = list()

#빈 리스트 선언 방법2
a = []

#크기가 N이고, 모든 값이 0인 1차원 리스트를 초기화하는 소스코드
n = 10
a = [0] * n
print(a) #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

### 리스트의 인덱싱과 슬라이싱

a라는 리스트의 두 번째 원소부터 네 번째 원소까지의 모든 데이터를 갖는 리스트를 가져오고 싶다면 a[1:4]

list_name[시작 인덱스: 끝 인덱스 -1]

### 리스트 컴프리헨션

리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.

리스트 컴프리헨션을 이용하면 대괄호([]) 안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있다.

```python
# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 ==1]
print(array) 
# [1,2,5,7,9,11,13,15,17,19]
```

```python
# 1부터 9까지 수의 제곱 값을 포함하는 리스트
array = [ i * i for i in range(1,10)]
print(array) 
# [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

**리스트 컴프리헨션은 2차원 리스트를 초기화할 때 매우 효과적으로 사용될 수 있습니다.**

```python
# N x M 크기의 2차원 리스트 초기화
n = 3
m =4
array = [[0] * m for _ in range(n)]
print(array) 
# [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
```

### 리스트 관련 기타 메서드

| 메서드명 | 사용법 | 설명 | 시간 복잡도 |
| --- | --- | --- | --- |
| append() | 변수명.append() | 리스트에 원소를 하나 삽입할 때 사용한다. | O(1) |
| sort() | 변수명.sort() | 기본 정렬 기능으로 오름차순으로 정렬한다. | O(NlogN) |
| sort() | 변수명.sort(reverse = True) | 내림차순으로 정렬한다. | O(N) |
| reverse() | 변수명.reverse() | 리스트의 원소의 순서를 모두 뒤집어 놓는다. | O(N) |
| insert() | 변수명.insert(삽입할 위치 인덱스, 삽입할 값) | 특정한 인덱스 위치에 원소를 삽입할 때 사용한다. | O(N) |
| count() | 변수명.count(특정 값) | 리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용한다. | O(N) |
| remove() | 변수명.remove(특정 값) | 특정한 값을 갖는 원소를 제거하는데, 값을 가진 언소가 여러 개면 하나만 제거한다. | O(N) |

특정한 값의 원소를 모두 제거하려면 다음과 같이 한다.

a에 포함된 원소를 하나씩 확인하며 그 원소가 remove_set에 포함되어 있지 않았을 떄만 리스트 변수인 result에 넣겠다는 의미.

```python
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

# remove_set에 포함되지 않은 값만을 저장
result = [i for i in a if i not remove_set]
print(result) 
# [1, 2, 4]
```

## 튜플 자료형

- 튜플은 한 번 선언된 값을 변경할 수 없다.
- 리스트는 대괄호[] 를 이용하지만, 튜플은 소괄호()를 이용한다.
- 튜플은 리스트에 비해 상대적으로 공간효율적이고, 일반적으로는 각 원소의 성질이 서로 다를 때 주로 사용한다.

```python
a = (1, 2, 3, 4)
print(a)
```

## 사전 자료형

### 사전 자료형 소개

파이썬의 사전 자료형은 내부적으로 ‘해시 테이블'을 이용하므로 기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다. 

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
print(data)
# '사과': 'Apple', '바나나': 'Banana', '코코넛': 'Coconut'}

# 사전 자료형에 특정한 원소가 있는지 검사할 때는 '원소 in 사전'의 형태를 사용
if '사과' in data:
	print("사과 데이터는 존재합니다.")
```

### 사전 자료형 관련 함수

키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용하며, 값 데이터만을 뽑아서 리스트로 이용할 때는 values()함수를 이용한다.

```python
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

# 키 데이터만 담은 리스트
key_list = data.keys()

# 값 데이터만 담은 리스트
value_list = data.values()

print(key_list) #dict_keys(['사과', '바나나', '코코넛'])
print(value_list) # dict_values(['Apple', 'Banana', 'Coconut'])

# 각 키에 따른 값을 하나씩 출력
for key in key_list:
	print(data[keys]) 
# Apple
# Banana
# Coconut
```

## 집합 자료형

### 집합 자료형 소개

- 중복을 허용하지 않는다.
- 순서가 없다. → 인덱싱으로 값을 얻을 수 없다.
- 키가 존재하지 않고, 값 데이터만을 담게 된다.
- 특정 원소가 존재하는 지를 검사하는 연산의 시간 복잡도는 사전 자료형과 마찬가지로 O(1) 이다.
- 특정한 데이터가 이미 등장한 적이 있는지 여부를 체크할 때 매우 효과적이다.
- 집합 자료형을 초기화할 때는 set() 함수를 이용하거나, 중괄호{} 안에 각 원소를 콤마(,)를 기준으로 구분해서 넣으면 된다

```python
# 집합 자료형 초기화 방법 1
data = set([1, 1, 2, 3, 4, 4, 5])
print(data)
# {1, 2, 3, 4, 5}

# 집합 자료형 초기화 방법 2
data = {1, 1, 2, 3, 4, 4, 5}
print(data) 
# {1, 2, 3, 4, 5}
```

### 집합 자료형의 연산
